!function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=1)}([function(t,e){},function(t,e,n){"use strict";n.r(e);var r=n(0);function i(t,e){for(const n of e)t.add(n)}function*s(t,e){for(let n=t;n<e;n+=1)yield n}class o{constructor(t,e,n){this.array=t,this.ROWS=e,this.COLS=n,this.POINT_COUNT=e*n}getRow(t){return Math.floor(t/this.COLS)}getCol(t){return t%this.COLS}countStatus(t){let e=0;for(const n of this.array)n===t&&(e+=1);return e}splitUnknownParts(){const t=new Array(this.array.length);function e(n){return t[n]<0?n:t[n]=e(t[n])}t.fill(-1);const n=(n,i)=>{var s,o;s=this.array[n],o=this.array[i],((s>=0||s===r.SAFE)&&(o>=0||o===r.SAFE)||s===o)&&function(n,r){const i=e(n),s=e(r);i!==s&&(t[i]<t[s]?(t[i]+=t[s],t[s]=i):(t[s]+=t[i],t[i]=s))}(n,i)};for(const t of s(0,this.ROWS))for(const e of s(0,this.COLS)){const r=t*this.COLS+e,i=r-this.COLS,s=r-1,o=r-this.COLS-1;e>=1&&n(r,s),t>=1&&n(r,i),t>=1&&e>=1&&n(r,o)}const i=new Map;for(const t of s(0,this.POINT_COUNT)){const n=e(t);this.array[n]===r.UNKNOWN&&(i.has(n)?i.get(n).push(t):i.set(n,[t]))}return i.values()}*neighbors(t){const e=this.getRow(t),n=this.getCol(t);for(const t of[-1,0,1])for(const r of[-1,0,1]){const i=e+t,s=n+r;i>=0&&i<this.ROWS&&s>=0&&s<this.COLS&&(yield i*this.COLS+s)}}group(t){const e=[],n=[],i=[],s=[];for(const o of t)switch(this.array[o]){case r.MINE:e.push(o);break;case r.SAFE:i.push(o);break;case r.UNKNOWN:n.push(o);break;default:s.push(o)}return{mines:e,unknowns:n,safes:i,normals:s}}apply(t,e){for(const n of t)this.array[n]=e}revert(t){this.apply(t,r.UNKNOWN)}check(t){for(const e of t){const{mines:t,unknowns:n}=this.group(this.neighbors(e)),r=t.length,i=t.length+n.length;if(!(r<=this.array[e]&&this.array[e]<=i))return!1}return!0}findRelated(t){const e=new Set;for(const n of t)for(const t of this.neighbors(n))this.array[t]>0&&e.add(t);return e}findExplicitMines(t){const e=new Set;let n;n=t?this.findRelated(t):Array.from(s(0,this.POINT_COUNT)).filter(t=>this.array[t]>0);for(const t of n){const{mines:n,unknowns:r}=this.group(this.neighbors(t));if(this.array[t]===r.length+n.length)for(const t of r)e.add(t)}return e}findExplicitSafes(t){const e=new Set;let n;n=t?this.findRelated(t):Array.from(s(0,this.POINT_COUNT)).filter(t=>this.array[t]>0);for(const t of n){const{mines:n,unknowns:r}=this.group(this.neighbors(t));if(this.array[t]===n.length)for(const t of r)e.add(t)}return e}explicitIterationFromSafe(t,e=!1){const n=new Set,s=new Set;let o=!1,a=t;for(;a.length>0;){const t=this.findExplicitMines(a);if(this.apply(t,r.MINE),i(n,t),e&&!this.check(this.findRelated(t))){o=!0;break}if(a=this.findExplicitSafes(t),this.apply(a,r.SAFE),i(s,a),e&&!this.check(this.findRelated(a))){o=!0;break}}return{foundMines:n,foundSafes:s,checkFailed:o}}explicitIterationFromMine(t,e=!1){const n=new Set,s=new Set;let o=!1,a=t;for(;a.length>0;){const t=this.findExplicitSafes(a);if(this.apply(t,r.SAFE),i(s,t),e&&!this.check(this.findRelated(t))){o=!0;break}if(a=this.findExplicitSafes(t),this.apply(a,r.MINE),i(n,a),e&&!this.check(this.findRelated(a))){o=!0;break}}return{foundMines:n,foundSafes:s,checkFailed:o}}canBeMine(t){this.array[t]=r.MINE;const{foundMines:e,foundSafes:n,checkFailed:i}=this.explicitIterationFromMine([t],!0);return this.array[t]=r.UNKNOWN,this.revert(e),this.revert(n),!i}canBeSafe(t){this.array[t]=r.SAFE;const{foundMines:e,foundSafes:n,checkFailed:i}=this.explicitIterationFromSafe([t],!1);return this.array[t]=r.UNKNOWN,this.revert(e),this.revert(n),!i}canBeResolve(t){return this.group(this.neighbors(t)).normals.length>0}sortByNearbyNumbers(t,e){const n=this.group(this.neighbors(t)).normals,r=this.group(this.neighbors(e)).normals;return n.reduce((t,e)=>Math.min(t,this.array[e]),9)-r.reduce((t,e)=>Math.min(t,this.array[e]),9)}resolve(t){return this.canBeMine(t)?this.canBeSafe(t)?r.UNKNOWN:r.MINE:r.SAFE}}function a(t){postMessage(JSON.stringify({type:"mine",value:Array.from(t)}))}function f(t){postMessage(JSON.stringify({type:"safe",value:Array.from(t)}))}onmessage=function(t){const e=JSON.parse(t.data);if("hint"!==e.type)throw new Error(`Invalid message type:${e.type}`);{const t=new o(e.array,e.ROWS,e.COLS),i=e.USE_AUTO,s=t.findExplicitMines();t.apply(s,r.MINE),a(s);const c=t.findExplicitSafes();t.apply(c,r.SAFE),f(c);let h=c,l=null;t:for(;;){if(h){const{foundMines:e,foundSafes:n}=t.explicitIterationFromSafe(h);a(e),f(n),h=null}if(l){const{foundMines:e,foundSafes:n}=t.explicitIterationFromMine(l);a(e),f(n),l=null}if(0===t.countStatus(r.SAFE))for(const e of t.splitUnknownParts()){e.sort(t.sortByNearbyNumbers.bind(t));for(const s of e){if(!t.canBeResolve(s))break;n=[s],postMessage(JSON.stringify({type:"danger",value:Array.from(n)}));const e=t.resolve(s);if(e!==r.UNKNOWN)if(e===r.SAFE){if(t.apply([s],r.SAFE),f([s]),i){h=[s];continue t}}else if(e===r.MINE&&(t.apply([s],r.MINE),a([s]),i)){l=[s];continue t}}}break}}var n}}]);